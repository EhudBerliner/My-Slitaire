<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Solitaire Pro v1.1</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2e7d32">
    <link rel="icon" type="image/jpeg" href="logo.jpg">

    <style>
        :root {
            --bg-color: #2e7d32;
            --card-width: 13vw;
            --card-height: calc(var(--card-width) * 1.4);
            --spacing: 8px;
        }
        @media (min-width: 600px) { :root { --card-width: 85px; } }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; background-color: var(--bg-color); font-family: -apple-system, system-ui, sans-serif; overflow: hidden; touch-action: none; height: 100vh; }

        header {
            height: 50px; background: rgba(0,0,0,0.4); color: white;
            display: flex; justify-content: space-between; align-items: center; padding: 0 15px;
            font-size: 0.9rem;
        }

        #gameBoard { padding: 10px; display: flex; flex-direction: column; gap: 15px; height: calc(100vh - 50px); max-width: 900px; margin: 0 auto; }
        .top-row { display: flex; justify-content: space-between; }
        .piles-group { display: flex; gap: var(--spacing); }

        .pile {
            width: var(--card-width); height: var(--card-height);
            border-radius: 6px; border: 1.5px solid rgba(255,255,255,0.15);
            position: relative; background: rgba(0,0,0,0.1);
        }

        .tableau-container { display: flex; justify-content: space-between; flex-grow: 1; }
        .tableau-col { width: var(--card-width); min-height: 200px; position: relative; }

        .card {
            width: var(--card-width); height: var(--card-height);
            background: white; border-radius: 5px; position: absolute;
            box-shadow: 1px 1px 4px rgba(0,0,0,0.4);
            display: flex; flex-direction: column; padding: 5px;
            font-weight: bold; font-size: 1rem; border: 0.5px solid #ccc;
        }
        .card.red { color: #e53935; }
        .card.black { color: #212121; }
        .card.back {
            background: #1565c0 linear-gradient(135deg, #1e88e5 25%, transparent 25%) -20px 0,
                        linear-gradient(225deg, #1e88e5 25%, transparent 25%) -20px 0,
                        linear-gradient(315deg, #1e88e5 25%, transparent 25%),
                        linear-gradient(45deg, #1e88e5 25%, transparent 25%);
            background-size: 40px 40px; border: 2px solid white;
        }
        
        /* Dragging state */
        .card.dragging { z-index: 10000 !important; pointer-events: none; opacity: 0.85; transform: scale(1.05); }
        .card-stack-drag { pointer-events: none; }

        /* Menu */
        .side-menu { position: fixed; top: 0; right: -280px; width: 260px; height: 100%; background: #fdfdfd; z-index: 2000; transition: 0.3s; padding: 25px; box-shadow: -5px 0 15px rgba(0,0,0,0.3); }
        .side-menu.open { transform: translateX(-280px); }
        .overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 1500; }
        .overlay.active { display: block; }
        
        button { background: #2e7d32; color: white; border: none; padding: 12px; border-radius: 4px; width: 100%; font-size: 1rem; cursor: pointer; margin-bottom: 10px; }
    </style>
</head>
<body>

    <header>
        <div onclick="toggleMenu()" style="cursor:pointer; font-size:1.5rem;">â˜°</div>
        <div>××”×œ×›×™×: <span id="moves">0</span> | × ×™×§×•×“: <span id="score">0</span></div>
        <div style="font-size: 0.7rem; opacity: 0.7;">v1.1</div>
    </header>

    <div id="sideMenu" class="side-menu">
        <h2 style="margin-top:0">Solitaire Pro</h2>
        <button onclick="app.newGame()">ğŸ”„ ××©×—×§ ×—×“×©</button>
        <button onclick="app.undo()">â†©ï¸ ×‘×˜×œ ××”×œ×š</button>
        <button onclick="toggleMenu()" style="background:#666">âŒ ×¡×’×•×¨</button>
    </div>
    <div id="overlay" class="overlay" onclick="toggleMenu()"></div>

    <main id="gameBoard">
        <div class="top-row">
            <div class="piles-group">
                <div id="stock" class="pile" onclick="app.draw()"></div>
                <div id="waste" class="pile"></div>
            </div>
            <div class="piles-group">
                <div id="f-0" class="pile foundation" data-type="foundation" data-idx="0"></div>
                <div id="f-1" class="pile foundation" data-type="foundation" data-idx="1"></div>
                <div id="f-2" class="pile foundation" data-type="foundation" data-idx="2"></div>
                <div id="f-3" class="pile foundation" data-type="foundation" data-idx="3"></div>
            </div>
        </div>
        <div id="tableau" class="tableau-container">
            <div class="tableau-col" data-type="tableau" data-idx="0"></div>
            <div class="tableau-col" data-type="tableau" data-idx="1"></div>
            <div class="tableau-col" data-type="tableau" data-idx="2"></div>
            <div class="tableau-col" data-type="tableau" data-idx="3"></div>
            <div class="tableau-col" data-type="tableau" data-idx="4"></div>
            <div class="tableau-col" data-type="tableau" data-idx="5"></div>
            <div class="tableau-col" data-type="tableau" data-idx="6"></div>
        </div>
    </main>

    <script>
        /**
         * Solitaire Pro - Unified Code Logic
         */
        const SYMBOLS = { h: 'â™¥', d: 'â™¦', c: 'â™£', s: 'â™ ' };
        const VALUES = { 1: 'A', 11: 'J', 12: 'Q', 13: 'K' };

        class Solitaire {
            constructor() {
                this.init();
            }

            init() {
                const suits = ['h', 'd', 'c', 's'];
                this.deck = [];
                suits.forEach(s => {
                    for (let v = 1; v <= 13; v++) {
                        this.deck.push({ suit: s, value: v, color: (s === 'h' || s === 'd') ? 'red' : 'black', faceUp: false });
                    }
                });
                this.shuffle(this.deck);
                
                this.tableau = [[], [], [], [], [], [], []];
                let dIdx = 0;
                for (let i = 0; i < 7; i++) {
                    for (let j = 0; j <= i; j++) {
                        let card = this.deck[dIdx++];
                        if (j === i) card.faceUp = true;
                        this.tableau[i].push(card);
                    }
                }
                this.stock = this.deck.slice(dIdx);
                this.waste = [];
                this.foundations = [[], [], [], []];
                this.score = 0;
                this.moves = 0;
                this.history = [];
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            save() {
                const state = JSON.stringify({
                    tableau: this.tableau, stock: this.stock, waste: this.waste, 
                    foundations: this.foundations, score: this.score, moves: this.moves
                });
                this.history.push(state);
                if (this.history.length > 30) this.history.shift();
            }
        }

        const game = new Solitaire();

        const ui = {
            render() {
                document.getElementById('score').innerText = game.score;
                document.getElementById('moves').innerText = game.moves;

                // Stock
                const stockEl = document.getElementById('stock');
                stockEl.innerHTML = game.stock.length ? `<div class="card back"></div>` : `<div style="display:flex; justify-content:center; align-items:center; height:100%; color:white; font-size:2rem; cursor:pointer">ğŸ”„</div>`;

                // Waste (Show last 3, but only top is draggable)
                const wasteEl = document.getElementById('waste');
                wasteEl.innerHTML = '';
                if (game.waste.length) {
                    const topCard = game.waste[game.waste.length - 1];
                    wasteEl.appendChild(this.createCard(topCard, 'waste'));
                }

                // Foundations
                game.foundations.forEach((f, i) => {
                    const fEl = document.getElementById(`f-${i}`);
                    fEl.innerHTML = '';
                    if (f.length) {
                        fEl.appendChild(this.createCard(f[f.length - 1], 'foundation', i));
                    }
                });

                // Tableau
                const colEls = document.querySelectorAll('.tableau-col');
                colEls.forEach((colEl, i) => {
                    colEl.innerHTML = '';
                    game.tableau[i].forEach((card, ci) => {
                        const cardEl = this.createCard(card, 'tableau', i, ci);
                        cardEl.style.top = (ci * 25) + 'px';
                        cardEl.style.zIndex = ci;
                        colEl.appendChild(cardEl);
                    });
                });
            },

            createCard(card, type, pIdx, cIdx) {
                const el = document.createElement('div');
                el.className = `card ${card.faceUp ? card.color : 'back'}`;
                if (card.faceUp) {
                    el.innerHTML = `<div>${VALUES[card.value] || card.value} ${SYMBOLS[card.suit]}</div>`;
                    this.attachDrag(el, card, type, pIdx, cIdx);
                }
                return el;
            },

            attachDrag(el, card, type, pIdx, cIdx) {
                let startX, startY, draggedEls = [];

                const onMove = (e) => {
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    const dx = clientX - startX;
                    const dy = clientY - startY;
                    draggedEls.forEach(obj => {
                        obj.el.style.transform = `translate(${dx}px, ${dy}px)`;
                    });
                };

                const onEnd = (e) => {
                    draggedEls.forEach(obj => obj.el.classList.remove('dragging'));
                    const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                    const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

                    // Hit detection
                    el.style.visibility = 'hidden';
                    const target = document.elementFromPoint(clientX, clientY);
                    el.style.visibility = 'visible';

                    const dropZone = target ? target.closest('[data-type]') : null;
                    if (dropZone) {
                        app.attemptMove(card, type, pIdx, cIdx, dropZone.dataset.type, parseInt(dropZone.dataset.idx));
                    }

                    window.removeEventListener('pointermove', onMove);
                    window.removeEventListener('pointerup', onEnd);
                    ui.render();
                };

                el.addEventListener('pointerdown', (e) => {
                    if (!card.faceUp) return;
                    game.save();
                    startX = e.clientX;
                    startY = e.clientY;
                    
                    // Identify stack
                    draggedEls = [];
                    if (type === 'tableau') {
                        const column = el.parentElement.children;
                        for (let i = cIdx; i < column.length; i++) {
                            const child = column[i];
                            child.classList.add('dragging');
                            child.style.zIndex = 1000 + i;
                            draggedEls.push({ el: child });
                        }
                    } else {
                        el.classList.add('dragging');
                        draggedEls.push({ el });
                    }

                    window.addEventListener('pointermove', onMove);
                    window.addEventListener('pointerup', onEnd);
                });
            }
        };

        const app = {
            draw() {
                game.save();
                if (game.stock.length === 0) {
                    this.recycle();
                    return;
                }
                // Draw 3 logic
                for (let i = 0; i < 3; i++) {
                    if (game.stock.length) {
                        let c = game.stock.pop();
                        c.faceUp = true;
                        game.waste.push(c);
                    }
                }
                game.moves++;
                ui.render();
            },

            recycle() {
                game.stock = game.waste.reverse().map(c => ({ ...c, faceUp: false }));
                game.waste = [];
                ui.render();
            },

            attemptMove(card, fromType, fromIdx, cardIdx, toType, toIdx) {
                const targetPile = toType === 'tableau' ? game.tableau[toIdx] : game.foundations[toIdx];
                const topTarget = targetPile.length ? targetPile[targetPile.length - 1] : null;

                let valid = false;
                if (toType === 'tableau') {
                    if (!topTarget) valid = (card.value === 13); // King to empty
                    else valid = (card.color !== topTarget.color && card.value === topTarget.value - 1);
                } else {
                    // Foundation: Only single card
                    if (fromType === 'tableau' && cardIdx !== game.tableau[fromIdx].length - 1) valid = false;
                    else {
                        if (!topTarget) valid = (card.value === 1); // Ace to foundation
                        else valid = (card.suit === topTarget.suit && card.value === topTarget.value + 1);
                    }
                }

                if (valid) {
                    let movingCards = [];
                    if (fromType === 'tableau') {
                        movingCards = game.tableau[fromIdx].splice(cardIdx);
                        if (game.tableau[fromIdx].length) {
                            game.tableau[fromIdx][game.tableau[fromIdx].length - 1].faceUp = true;
                        }
                    } else if (fromType === 'waste') {
                        movingCards = [game.waste.pop()];
                    } else if (fromType === 'foundation') {
                        movingCards = [game.foundations[fromIdx].pop()];
                    }

                    targetPile.push(...movingCards);
                    game.moves++;
                    game.score += (toType === 'foundation' ? 15 : 5);
                    this.checkWin();
                }
                ui.render();
            },

            undo() {
                if (game.history.length) {
                    const last = JSON.parse(game.history.pop());
                    Object.assign(game, last);
                    ui.render();
                }
                toggleMenu();
            },

            newGame() {
                if (confirm("×œ×”×ª×—×™×œ ××©×—×§ ×—×“×©?")) {
                    game.init();
                    ui.render();
                    toggleMenu();
                }
            },

            checkWin() {
                const win = game.foundations.every(f => f.length === 13);
                if (win) alert("×›×œ ×”×›×‘×•×“! × ×™×¦×—×ª!");
            }
        };

        function toggleMenu() {
            document.getElementById('sideMenu').classList.toggle('open');
            document.getElementById('overlay').classList.toggle('active');
        }

        // Init
        ui.render();
        if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');
    </script>
</body>
</html>
