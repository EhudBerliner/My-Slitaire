<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Solitaire Pro PWA</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2e7d32">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="icon" type="image/png" href="logo.png">
    <link rel="apple-touch-icon" href="logo.png">

    <style>
        :root {
            --bg-color: #2e7d32;
            --card-ratio: 1.4;
            --card-width: 13vw; /* Mobile default */
            --card-height: calc(var(--card-width) * var(--card-ratio));
            --spacing: 8px;
            --text-color: #fff;
            --accent-color: #ffd700;
        }

        @media (min-width: 600px) {
            :root {
                --card-width: 80px; 
            }
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
        }

        /* Header */
        header {
            height: 60px;
            background: rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
            color: var(--text-color);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .header-left { display: flex; align-items: center; gap: 15px; }
        .game-info span { display: block; font-size: 0.75rem; opacity: 0.9; }
        .game-info b { font-size: 0.9rem; color: var(--accent-color); }
        .icon-btn { background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; }

        .title-block { text-align: center; line-height: 1; }
        h1 { margin: 0; font-size: 1.2rem; }
        .version-badge { 
            font-size: 0.65rem; background: rgba(255,255,255,0.2); 
            padding: 2px 6px; border-radius: 4px; cursor: pointer; 
        }
        .version-badge:hover { background: red; }

        /* Menu */
        .side-menu {
            position: fixed; top: 0; right: -280px; width: 260px; height: 100%;
            background: #f4f4f4; color: #333; z-index: 1000;
            transition: transform 0.3s ease;
            box-shadow: -5px 0 15px rgba(0,0,0,0.2);
            display: flex; flex-direction: column;
        }
        .side-menu.open { transform: translateX(-280px); }
        .menu-header { display: flex; justify-content: space-between; padding: 20px; border-bottom: 1px solid #ddd; }
        .menu-list { list-style: none; padding: 0; margin: 0; }
        .menu-list li { padding: 15px 20px; border-bottom: 1px solid #eee; cursor: pointer; display: flex; align-items: center; gap: 10px; }
        .menu-list li:active { background: #e0e0e0; }
        .overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 999; }
        .overlay.active { display: block; }
        .settings-area { padding: 20px; margin-top: auto; background: #e9e9e9; }

        /* Board */
        #gameBoard { padding: 10px; max-width: 900px; margin: 0 auto; height: calc(100vh - 60px); }
        .top-row { display: flex; justify-content: space-between; margin-bottom: 2vh; }
        .stock-container, .foundations-container { display: flex; gap: var(--spacing); }

        .pile {
            width: var(--card-width); height: var(--card-height);
            border-radius: 5px;
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
            display: flex; justify-content: center; align-items: center;
        }
        .foundation { font-size: 2rem; color: rgba(255,255,255,0.3); background: rgba(0,0,0,0.1); }
        .stock.refresh-btn { font-size: 2rem; cursor: pointer; }

        .tableau-container { display: flex; justify-content: space-between; height: 100%; }
        .tableau-col { width: var(--card-width); position: relative; height: 100%; }

        /* Cards */
        .card {
            width: var(--card-width); height: var(--card-height);
            background: white; border-radius: 5px;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            position: absolute; top: 0; left: 0;
            display: flex; flex-direction: column; justify-content: space-between; padding: 2px 5px;
            font-weight: bold; font-size: 1.1rem;
            transition: transform 0.1s;
            will-change: transform, top, left;
        }
        .card.red { color: #d32f2f; }
        .card.black { color: #212121; }
        .card.back {
            background: repeating-linear-gradient(45deg, #1976d2, #1976d2 10px, #1565c0 10px, #1565c0 20px);
            border: 2px solid #fff;
        }
        .card.dragging { z-index: 9999 !important; pointer-events: none; opacity: 0.9; box-shadow: 5px 5px 15px rgba(0,0,0,0.5); }
    </style>
</head>
<body>

    <header>
        <div class="header-left">
            <button id="menuBtn" class="icon-btn">â˜°</button>
            <div class="game-info">
                <span>××”×œ×›×™×: <b id="movesDisplay">0</b></span>
                <span>× ×™×§×•×“: <b id="scoreDisplay">0</b></span>
            </div>
        </div>
        <div class="header-right">
            <div class="title-block">
                <h1>×¡×•×œ×™×˜×¨</h1>
                <small id="versionDisplay" class="version-badge">v1.0.6 (Unified)</small>
            </div>
        </div>
    </header>

    <div id="sideMenu" class="side-menu">
        <div class="menu-header">
            <h2>×ª×¤×¨×™×˜</h2>
            <button id="closeMenuBtn">âœ•</button>
        </div>
        <ul class="menu-list">
            <li onclick="app.game.startNewGame()">ğŸ”„ ××©×—×§ ×—×“×©</li>
            <li onclick="app.game.undo()">â†©ï¸ ×‘×˜×œ ××”×œ×š</li>
            <li onclick="app.game.showHint()">ğŸ’¡ ×§×‘×œ ×¨××–</li>
            <li onclick="alert('×”×’×¨×¡×” ×”×××•×—×“×ª!')">â„¹ï¸ ××•×“×•×ª</li>
        </ul>
    </div>
    <div id="overlay" class="overlay"></div>

    <main id="gameBoard">
        <div class="top-row">
            <div class="stock-container">
                <div id="stock" class="pile stock"></div>
                <div id="waste" class="pile waste"></div>
            </div>
            <div class="foundations-container">
                <div id="f-0" class="pile foundation" data-suit="hearts">â™¥</div>
                <div id="f-1" class="pile foundation" data-suit="diamonds">â™¦</div>
                <div id="f-2" class="pile foundation" data-suit="clubs">â™£</div>
                <div id="f-3" class="pile foundation" data-suit="spades">â™ </div>
            </div>
        </div>
        
        <div id="tableau" class="tableau-container">
            </div>
    </main>

    <script>
        /** * SOLITAIRE PWA - UNIFIED SINGLE FILE
         */

        // ================= GAME LOGIC =================
        class SolitaireGame {
            constructor() {
                this.deck = []; this.stock = []; this.waste = [];
                this.foundations = [[], [], [], []];
                this.tableau = [[], [], [], [], [], [], []];
                this.history = []; this.score = 0; this.moves = 0;
            }

            init() {
                this.createDeck(); this.shuffle(); this.deal();
                this.history = []; this.score = 0; this.moves = 0;
            }

            createDeck() {
                const suits = ['h', 'd', 'c', 's'];
                const values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
                this.deck = [];
                for (let s of suits) {
                    for (let v of values) {
                        this.deck.push({
                            suit: s, value: v,
                            color: (s === 'h' || s === 'd') ? 'red' : 'black',
                            faceUp: false, id: `${s}-${v}`
                        });
                    }
                }
            }

            shuffle() {
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            deal() {
                this.tableau = [[], [], [], [], [], [], []];
                let cardIdx = 0;
                for (let i = 0; i < 7; i++) {
                    for (let j = 0; j <= i; j++) {
                        let card = this.deck[cardIdx++];
                        if (j === i) card.faceUp = true;
                        this.tableau[i].push(card);
                    }
                }
                this.stock = this.deck.slice(cardIdx);
                this.waste = []; this.foundations = [[], [], [], []];
            }

            saveState() {
                const state = JSON.stringify({
                    stock: this.stock, waste: this.waste,
                    foundations: this.foundations, tableau: this.tableau,
                    score: this.score, moves: this.moves
                });
                this.history.push(state);
                if (this.history.length > 20) this.history.shift();
            }

            undo() {
                if (this.history.length === 0) return false;
                const state = JSON.parse(this.history.pop());
                Object.assign(this, state);
                return true;
            }

            isValidMove(card, target, type) {
                if (type === 'foundation') {
                    if (!target) return card.value === 1;
                    return card.suit === target.suit && card.value === target.value + 1;
                } else {
                    if (!target) return card.value === 13;
                    return card.color !== target.color && card.value === target.value - 1;
                }
            }
        }

        // ================= UI MANAGER =================
        class UIManager {
            constructor(game) {
                this.game = game;
                this.draggedCard = null;
                this.elTableau = document.getElementById('tableau');
                this.elStock = document.getElementById('stock');
                this.elWaste = document.getElementById('waste');
            }

            render() {
                // Stock & Waste
                this.elStock.innerHTML = this.game.stock.length ? `<div class="card back" onclick="app.drawStock()"></div>` : `<div class="stock refresh-btn" onclick="app.resetStock()">ğŸ”„</div>`;
                this.elWaste.innerHTML = '';
                if (this.game.waste.length) {
                    let card = this.game.waste[this.game.waste.length - 1];
                    this.elWaste.appendChild(this.createCardEl(card));
                }

                // Foundations
                this.game.foundations.forEach((pile, idx) => {
                    const el = document.getElementById(`f-${idx}`);
                    el.innerHTML = pile.length ? '' : el.getAttribute('data-suit');
                    if (pile.length) el.appendChild(this.createCardEl(pile[pile.length - 1]));
                });

                // Tableau
                this.elTableau.innerHTML = '';
                this.game.tableau.forEach((col, colIdx) => {
                    let colDiv = document.createElement('div');
                    colDiv.className = 'tableau-col';
                    colDiv.addEventListener('pointerup', (e) => this.handleDrop(e, 'tableau', colIdx));

                    let topOffset = 0;
                    col.forEach((card, cardIdx) => {
                        let cardEl = this.createCardEl(card);
                        cardEl.style.top = `${topOffset}px`;
                        cardEl.style.zIndex = cardIdx;
                        if (card.faceUp) this.addDragEvents(cardEl, card, colIdx, cardIdx);
                        colDiv.appendChild(cardEl);
                        topOffset += card.faceUp ? 30 : 12;
                    });
                    this.elTableau.appendChild(colDiv);
                });

                document.getElementById('scoreDisplay').innerText = this.game.score;
                document.getElementById('movesDisplay').innerText = this.game.moves;
            }

            createCardEl(card) {
                let el = document.createElement('div');
                el.className = `card ${card.faceUp ? card.color : 'back'}`;
                if (card.faceUp) {
                    const suitMap = { 'h':'â™¥', 'd':'â™¦', 'c':'â™£', 's':'â™ ' };
                    const valMap = { 1:'A', 11:'J', 12:'Q', 13:'K' };
                    let val = valMap[card.value] || card.value;
                    el.innerHTML = `<div>${val} ${suitMap[card.suit]}</div>`;
                }
                return el;
            }

            addDragEvents(el, card, colIdx, cardIdx) {
                el.addEventListener('pointerdown', (e) => {
                    e.stopPropagation();
                    this.draggedCard = { el, card, colIdx, cardIdx };
                    this.game.saveState();
                    el.classList.add('dragging');
                    el.setPointerCapture(e.pointerId);
                });
                el.addEventListener('pointermove', (e) => {
                    if (!this.draggedCard || this.draggedCard.el !== el) return;
                    const parentRect = el.parentElement.getBoundingClientRect();
                    // Simple centering drag
                    el.style.left = `${e.clientX - parentRect.left - (el.offsetWidth/2)}px`;
                    el.style.top = `${e.clientY - parentRect.top - (el.offsetHeight/2)}px`;
                });
                el.addEventListener('pointerup', (e) => {
                    if (!this.draggedCard) return;
                    el.classList.remove('dragging');
                    this.draggedCard = null;
                    this.render(); // Snap back if dropped invalidly
                });
            }

            handleDrop(e, targetType, targetIdx) {
                if (!this.draggedCard) return;
                app.attemptMove(this.draggedCard, targetType, targetIdx);
            }
        }

        // ================= PWA MANAGER =================
        const PWA_Manager = {
            init() {
                document.getElementById('versionDisplay').onclick = this.hardReset;
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('sw.js').catch(console.error);
                }
            },
            async hardReset() {
                if(!confirm("×œ×‘×¦×¢ ××™×¤×•×¡ ××œ× ×•×”×ª×§× ×” ××—×“×©?")) return;
                if ('serviceWorker' in navigator) {
                    const regs = await navigator.serviceWorker.getRegistrations();
                    for (let reg of regs) await reg.unregister();
                }
                if ('caches' in window) {
                    const keys = await caches.keys();
                    await Promise.all(keys.map(k => caches.delete(k)));
                }
                localStorage.clear();
                window.location.reload(true);
            }
        };

        // ================= MAIN APP =================
        const gameInstance = new SolitaireGame();
        const uiInstance = new UIManager(gameInstance);

        const app = {
            start() {
                PWA_Manager.init();
                this.loadGame();
            },
            drawStock() {
                gameInstance.saveState();
                if (gameInstance.stock.length > 0) {
                    let card = gameInstance.stock.pop();
                    card.faceUp = true;
                    gameInstance.waste.push(card);
                }
                uiInstance.render();
            },
            resetStock() {
                gameInstance.saveState();
                gameInstance.stock = gameInstance.waste.reverse().map(c => { c.faceUp = false; return c; });
                gameInstance.waste = [];
                uiInstance.render();
            },
            attemptMove(dragInfo, targetType, targetIdx) {
                const { card, colIdx, cardIdx } = dragInfo;
                let targetCol = (targetType === 'tableau') ? gameInstance.tableau[targetIdx] : gameInstance.foundations[targetIdx];
                let targetCard = targetCol.length ? targetCol[targetCol.length - 1] : null;

                if (gameInstance.isValidMove(card, targetCard, targetType)) {
                    let cardsToMove = (colIdx !== undefined) ? gameInstance.tableau[colIdx].splice(cardIdx) : [gameInstance.waste.pop()];
                    
                    if (colIdx !== undefined && gameInstance.tableau[colIdx].length > 0) {
                        gameInstance.tableau[colIdx][gameInstance.tableau[colIdx].length - 1].faceUp = true;
                    }
                    
                    if (targetType === 'tableau') {
                         gameInstance.tableau[targetIdx].push(...cardsToMove);
                    } else {
                         gameInstance.foundations[targetIdx].push(cardsToMove[0]);
                         gameInstance.score += 10;
                    }
                    gameInstance.moves++;
                    this.saveGame();
                }
                uiInstance.render();
            },
            saveGame() {
                localStorage.setItem('solitaire_state_unified', JSON.stringify({
                    stock: gameInstance.stock, waste: gameInstance.waste,
                    tableau: gameInstance.tableau, foundations: gameInstance.foundations,
                    score: gameInstance.score, moves: gameInstance.moves
                }));
            },
            loadGame() {
                const saved = localStorage.getItem('solitaire_state_unified');
                if (saved) {
                    Object.assign(gameInstance, JSON.parse(saved));
                } else {
                    gameInstance.init();
                }
                uiInstance.render();
            },
            game: {
                startNewGame: () => { gameInstance.init(); uiInstance.render(); app.saveGame(); app.closeMenu(); },
                undo: () => { if(gameInstance.undo()) uiInstance.render(); app.closeMenu(); },
                showHint: () => { alert("×¨××–: × ×¡×” ×œ×¤× ×•×ª ×§×œ×¤×™× ×œ×¢×¨×™××•×ª ×”×‘×¡×™×¡."); app.closeMenu(); }
            },
            closeMenu: () => {
                document.getElementById('sideMenu').classList.remove('open');
                document.getElementById('overlay').classList.remove('active');
            }
        };

        // Menu Toggles
        document.getElementById('menuBtn').onclick = () => {
            document.getElementById('sideMenu').classList.add('open');
            document.getElementById('overlay').classList.add('active');
        };
        document.getElementById('closeMenuBtn').onclick = app.closeMenu;
        document.getElementById('overlay').onclick = app.closeMenu;

        // Init
        app.start();
    </script>
</body>
</html>